AWS 3-Tier Architecture with High Availability & Fault Tolerance
================================================================

1. PROJECT OVERVIEW
-------------------
This project implements a production-style AWS 3-Tier Architecture designed for scalability, security, and high availability.

The application is divided into three layers:

1. Web Tier (Presentation Layer)
2. Application Tier (Business Logic Layer)
3. Database Tier (Data Layer)

------------------------------------------------------------

2. ARCHITECTURE SUMMARY
------------------------
The project follows a production-style 3-tier architecture:

1. Web Tier (Presentation Layer)
2. Application Tier (Business Logic Layer)
3. Database Tier (Data Layer)

Traffic Flow:
User → Route53 → External ALB → Web Tier → Internal ALB → App Tier → Amazon RDS

Core design principles:
- Network isolation between tiers
- High availability across multiple Availability Zones
- Secure backend communication
- Scalable infrastructure using Auto Scalinge architecture follows DevOps and cloud best practices including network isolation, load balancing, auto scaling, and secure tier-to-tier communication.

------------------------------------------------------------


3. AWS SERVICES USED
--------------------
- Amazon VPC
- Public & Private Subnets
- Internet Gateway
- NAT Gateway
- Amazon EC2
- Amazon S3
- IAM Roles
- Amazon RDS (MySQL Multi-AZ)
- Application Load Balancer (External & Internal)
- Auto Scaling Group
- AWS Certificate Manager (ACM)
- Amazon Route 53

------------------------------------------------------------

4. ARCHITECTURE OVERVIEW
-------------------------
- User requests enter through Route53 DNS.
- External ALB routes traffic to Web Tier instances.
- Web Tier serves frontend and forwards API requests.
- Internal ALB distributes API traffic to App Tier instances.
- App Tier processes business logic and communicates with RDS.
- Database tier remains isolated inside private subnets.

Key Features:
- Multi-AZ deployment for fault tolerance
- Internal Load Balancer to secure backend APIs
- Private database subnet isolation
- NAT Gateway for secure outbound internet access

------------------------------------------------------------

5. END-TO-END REQUEST FLOW
---------------------------
1. User accesses application via custom domain.
2. Route53 resolves DNS and forwards traffic to External ALB.
3. External ALB routes requests to Web Tier EC2 instances.
4. Web Tier serves frontend content.
5. API requests are forwarded to Internal ALB.
6. Internal ALB routes requests to App Tier instances.
7. App Tier processes logic and queries Amazon RDS.
8. Response returns through the same secure path.

------------------------------------------------------------

6. DEPLOYMENT STEPS
-------------------

STEP 1 — VPC & Networking Setup
--------------------------------
- Create custom VPC 
- Create:
  - 2 Public Subnets (Web Tier + External ALB)
  - 2 Private App Subnets
  - 2 Private DB Subnets
- Attach Internet Gateway
- Configure NAT Gateway
- Configure route tables

STEP 2 — S3 & IAM Configuration
--------------------------------
- Create S3 bucket for application artifacts
- Upload web-tier and app-tier code
- Create IAM role with AmazonS3ReadOnlyAccess
- Attach IAM role to EC2 instances

STEP 3 — RDS Setup
------------------
- Create DB subnet group (private subnets)
- Deploy MySQL RDS instance (Multi-AZ enabled)
- Disable public access
- Allow MySQL access only from App Tier Security Group

STEP 4 — Application Tier Setup
-------------------------------
- Launch EC2 instances in private subnets
- Install runtime dependencies
- Pull code from S3
- Configure database connection
- Start application using PM2

STEP 4.2 — Internal Load Balancer
---------------------------------
- Create target group (Port 4000)
- Configure health check (/health)
- Create Internal ALB
- Attach App Tier instances

STEP 5 — Web Tier Setup
-----------------------
- Launch Web Tier EC2 instances
- Install Node.js runtime and NGINX
- Download frontend code from S3
- Configure NGINX reverse proxy to Internal ALB

STEP 5.2 — External Load Balancer
---------------------------------
- Create target group for Web Tier
- Create Internet-facing ALB
- Attach Web Tier instances

STEP 6 — Application Validation
-------------------------------
- Verify frontend accessibility via External ALB
- Validate API communication and database connectivity

STEP 7 — Auto Scaling
---------------------
- Create AMI from App Tier instance
- Create Launch Template
- Configure Auto Scaling Group
  - Minimum: 2
  - Desired: 2
  - Maximum: 4
- Attach ASG to Internal ALB

STEP 8 — SSL + Custom Domain Setup
-----------------------------------
- Request SSL certificate via ACM
- Validate domain using Route53 DNS records
- Add HTTPS listener (443) to External ALB
- Attach SSL certificate

STEP 9 — Access Application
---------------------------
- Access application securely via:
  https://your-domain-name.com

------------------------------------------------------------

7. SECURITY IMPLEMENTATION
--------------------------
- Security groups enforce tier-to-tier communication.
- App and DB tiers are private (no public IP).
- Database access restricted to App Tier SG only.
- HTTPS enabled using ACM certificates.
- IAM roles used for secure service access.
- Secrets should be stored using AWS Secrets Manager.

------------------------------------------------------------

8. HIGH AVAILABILITY & FAULT TOLERANCE
--------------------------------------
- Multi-AZ deployment of subnets and RDS.
- Load balancers distribute traffic across healthy instances.
- Auto Scaling replaces unhealthy instances automatically.
- Stateless application design supports scaling.

------------------------------------------------------------

9. CHALLENGES FACED & SOLUTIONS
--------------------------------
Challenges:
- Configuring NGINX reverse proxy for internal API routing.
- Enabling internet access for private instances securely.
- SSL certificate validation via DNS.

Solutions:
- Used Internal ALB DNS in nginx.conf.
- Configured NAT Gateway for outbound traffic.
- Used ACM DNS validation with Route53.

------------------------------------------------------------

10. DEVOPS SKILLS DEMONSTRATED
-------------------------------
- AWS cloud architecture design
- Secure VPC networking
- Load balancing strategy
- Auto Scaling implementation
- Linux server management
- NGINX reverse proxy configuration
- High availability design principles

------------------------------------------------------------

11. FUTURE IMPROVEMENTS
-----------------------
- Infrastructure as Code using Terraform
- CI/CD pipeline using Jenkins or GitHub Actions
- Monitoring using CloudWatch and Grafana
- Centralized logging and alerting
- AWS WAF integration for additional security

------------------------------------------------------------

12. LESSONS LEARNED
-------------------
- Internal load balancing improves API security.
- Private subnets reduce attack surface significantly.
- Auto Scaling requires stateless application architecture.
- Proper network design simplifies scaling and maintenance.

------------------------------------------------------------


13. REPOSITORY
--------------
https://github.com/harshal019/AWS-3-Tier-Architecture

============================================================

